#!/usr/bin/env python3
"""
Test Search Methods Comparison
So s√°nh hi·ªáu su·∫•t c√°c ph∆∞∆°ng ph√°p t√¨m ki·∫øm: Semantic, Hybrid, Parallel, Fast Hybrid
"""

import time
import json
import statistics
from datetime import datetime
from typing import List, Dict, Any

# Import search methods
from medical_rag_utils import search_medical_symptoms_and_diseases
try:
    from hybrid_search import get_hybrid_search_engine
    HYBRID_AVAILABLE = True
except ImportError:
    HYBRID_AVAILABLE = False
    print("‚ö†Ô∏è Hybrid search not available")

try:
    from async_processor import get_async_processor
    PARALLEL_AVAILABLE = True
except ImportError:
    PARALLEL_AVAILABLE = False
    print("‚ö†Ô∏è Parallel search not available")

try:
    from enhanced_search_quality import get_search_quality_enhancer
    ENHANCED_SEARCH_AVAILABLE = True
except ImportError:
    ENHANCED_SEARCH_AVAILABLE = False
    print("‚ö†Ô∏è Enhanced search not available")

class SearchComparison:
    """Class ƒë·ªÉ test v√† so s√°nh c√°c ph∆∞∆°ng ph√°p search"""
    
    def __init__(self):
        self.test_queries = [
            "ƒëau ƒë·∫ßu v√† ch√≥ng m·∫∑t",
            "s·ªët cao k√©o d√†i",
            "ho khan c√≥ m√°u",
            "ƒëau b·ª•ng d∆∞·ªõi b√™n ph·∫£i", 
            "kh√≥ th·ªü v√† ƒëau ng·ª±c",
            "m·ªát m·ªèi k√©o d√†i",
            "bu·ªìn n√¥n v√† n√¥n",
            "r·ªëi lo·∫°n ti√™u h√≥a",
            "cao huy·∫øt √°p",
            "ti·ªÉu ƒë∆∞·ªùng type 2",
            "vi√™m ph·ªïi",
            "covid-19 tri·ªáu ch·ª©ng",
            "ƒëau kh·ªõp g·ªëi",
            "m·∫•t ng·ªß",
            "stress v√† lo √¢u"
        ]
        
        self.results = {}
        self.setup_search_engines()
    
    def setup_search_engines(self):
        """Kh·ªüi t·∫°o c√°c search engines"""
        print("üîß Initializing search engines...")
        
        # Hybrid Search
        if HYBRID_AVAILABLE:
            try:
                self.hybrid_engine = get_hybrid_search_engine()
                print("‚úÖ Hybrid search engine loaded")
            except Exception as e:
                print(f"‚ùå Hybrid search failed: {e}")
                self.hybrid_engine = None
        else:
            self.hybrid_engine = None
        
        # Parallel Search  
        if PARALLEL_AVAILABLE:
            try:
                self.parallel_processor = get_async_processor()
                print("‚úÖ Parallel processor loaded")
            except Exception as e:
                print(f"‚ùå Parallel search failed: {e}")
                self.parallel_processor = None
        else:
            self.parallel_processor = None
        
        # Enhanced Search
        if ENHANCED_SEARCH_AVAILABLE:
            try:
                self.enhanced_search = get_search_quality_enhancer()
                print("‚úÖ Enhanced search loaded")
            except Exception as e:
                print(f"‚ùå Enhanced search failed: {e}")
                self.enhanced_search = None
        else:
            self.enhanced_search = None
    
    def test_semantic_search(self, query: str, top_k: int = 5) -> Dict[str, Any]:
        """Test semantic search (baseline)"""
        start_time = time.time()
        
        try:
            results = search_medical_symptoms_and_diseases(query, top_k=top_k)
            search_time = time.time() - start_time
            
            return {
                'method': 'semantic',
                'success': True,
                'results_count': len(results),
                'search_time': search_time,
                'results': results[:3],  # Top 3 for analysis
                'error': None
            }
            
        except Exception as e:
            return {
                'method': 'semantic', 
                'success': False,
                'results_count': 0,
                'search_time': time.time() - start_time,
                'results': [],
                'error': str(e)
            }
    
    def test_hybrid_search(self, query: str, top_k: int = 5) -> Dict[str, Any]:
        """Test hybrid search"""
        start_time = time.time()
        
        if not self.hybrid_engine:
            return {
                'method': 'hybrid',
                'success': False,
                'results_count': 0,
                'search_time': 0,
                'results': [],
                'error': 'Hybrid engine not available'
            }
        
        try:
            results = self.hybrid_engine.hybrid_search(query, top_k=top_k)
            search_time = time.time() - start_time
            
            return {
                'method': 'hybrid',
                'success': True,
                'results_count': len(results),
                'search_time': search_time,
                'results': results[:3],
                'error': None
            }
            
        except Exception as e:
            return {
                'method': 'hybrid',
                'success': False,
                'results_count': 0,
                'search_time': time.time() - start_time,
                'results': [],
                'error': str(e)
            }
    
    def test_parallel_search(self, query: str, top_k: int = 5) -> Dict[str, Any]:
        """Test parallel search"""
        start_time = time.time()
        
        if not self.parallel_processor:
            return {
                'method': 'parallel',
                'success': False,
                'results_count': 0,
                'search_time': 0,
                'results': [],
                'error': 'Parallel processor not available'
            }
        
        try:
            # Parallel search v·ªõi multiple methods
            parallel_results = self.parallel_processor.parallel_search(
                query, 
                search_methods=['semantic', 'keyword'], 
                top_k=top_k
            )
            
            search_time = time.time() - start_time
            
            # Combine results from different methods
            combined_results = []
            if parallel_results.get('semantic'):
                combined_results.extend(parallel_results['semantic'][:3])
            if parallel_results.get('keyword'):
                combined_results.extend(parallel_results['keyword'][:2])
            
            return {
                'method': 'parallel',
                'success': True,
                'results_count': len(combined_results),
                'search_time': search_time,
                'results': combined_results[:3],
                'error': None,
                'breakdown': {
                    'semantic_count': len(parallel_results.get('semantic', [])),
                    'keyword_count': len(parallel_results.get('keyword', []))
                }
            }
            
        except Exception as e:
            return {
                'method': 'parallel',
                'success': False,
                'results_count': 0,
                'search_time': time.time() - start_time,
                'results': [],
                'error': str(e)
            }
    
    def test_fast_hybrid_search(self, query: str, top_k: int = 5) -> Dict[str, Any]:
        """Test fast hybrid search (enhanced)"""
        start_time = time.time()
        
        if not self.enhanced_search:
            return {
                'method': 'fast_hybrid',
                'success': False,
                'results_count': 0,
                'search_time': 0,
                'results': [],
                'error': 'Enhanced search not available'
            }
        
        try:
            results = self.enhanced_search.enhanced_search(query, top_k=top_k)
            search_time = time.time() - start_time
            
            return {
                'method': 'fast_hybrid',
                'success': True,
                'results_count': len(results),
                'search_time': search_time,
                'results': results[:3],
                'error': None
            }
            
        except Exception as e:
            return {
                'method': 'fast_hybrid',
                'success': False,
                'results_count': 0,
                'search_time': time.time() - start_time,
                'results': [],
                'error': str(e)
            }
    
    def run_single_query_test(self, query: str, top_k: int = 5) -> Dict[str, Any]:
        """Test single query v·ªõi t·∫•t c·∫£ methods"""
        print(f"\nüîç Testing query: '{query}'")
        
        query_results = {
            'query': query,
            'timestamp': datetime.now().isoformat(),
            'methods': {}
        }
        
        # Test semantic search
        semantic_result = self.test_semantic_search(query, top_k)
        query_results['methods']['semantic'] = semantic_result
        print(f"  üìä Semantic: {semantic_result['results_count']} results in {semantic_result['search_time']:.3f}s")
        
        # Test hybrid search
        hybrid_result = self.test_hybrid_search(query, top_k)
        query_results['methods']['hybrid'] = hybrid_result
        if hybrid_result['success']:
            print(f"  üîÑ Hybrid: {hybrid_result['results_count']} results in {hybrid_result['search_time']:.3f}s")
        else:
            print(f"  ‚ùå Hybrid: {hybrid_result['error']}")
        
        # Test parallel search
        parallel_result = self.test_parallel_search(query, top_k)
        query_results['methods']['parallel'] = parallel_result
        if parallel_result['success']:
            print(f"  ‚ö° Parallel: {parallel_result['results_count']} results in {parallel_result['search_time']:.3f}s")
        else:
            print(f"  ‚ùå Parallel: {parallel_result['error']}")
        
        # Test fast hybrid search
        fast_hybrid_result = self.test_fast_hybrid_search(query, top_k)
        query_results['methods']['fast_hybrid'] = fast_hybrid_result
        if fast_hybrid_result['success']:
            print(f"  üöÄ Fast Hybrid: {fast_hybrid_result['results_count']} results in {fast_hybrid_result['search_time']:.3f}s")
        else:
            print(f"  ‚ùå Fast Hybrid: {fast_hybrid_result['error']}")
        
        return query_results
    
    def run_full_comparison(self, top_k: int = 5) -> Dict[str, Any]:
        """Ch·∫°y test to√†n b·ªô v·ªõi t·∫•t c·∫£ queries"""
        print("üöÄ Starting Full Search Comparison Test")
        print(f"üìã Testing {len(self.test_queries)} queries with top_k={top_k}")
        print("-" * 60)
        
        all_results = []
        method_stats = {
            'semantic': {'times': [], 'success_count': 0, 'total_results': 0},
            'hybrid': {'times': [], 'success_count': 0, 'total_results': 0},
            'parallel': {'times': [], 'success_count': 0, 'total_results': 0},
            'fast_hybrid': {'times': [], 'success_count': 0, 'total_results': 0}
        }
        
        for i, query in enumerate(self.test_queries, 1):
            print(f"\n[{i}/{len(self.test_queries)}]", end="")
            query_result = self.run_single_query_test(query, top_k)
            all_results.append(query_result)
            
            # Collect stats
            for method_name, method_result in query_result['methods'].items():
                if method_result['success']:
                    method_stats[method_name]['times'].append(method_result['search_time'])
                    method_stats[method_name]['success_count'] += 1
                    method_stats[method_name]['total_results'] += method_result['results_count']
        
        # Calculate statistics
        summary = {
            'test_info': {
                'total_queries': len(self.test_queries),
                'top_k': top_k,
                'timestamp': datetime.now().isoformat()
            },
            'method_stats': {},
            'detailed_results': all_results
        }
        
        for method_name, stats in method_stats.items():
            if stats['times']:
                summary['method_stats'][method_name] = {
                    'success_rate': stats['success_count'] / len(self.test_queries),
                    'avg_time': statistics.mean(stats['times']),
                    'min_time': min(stats['times']),
                    'max_time': max(stats['times']),
                    'median_time': statistics.median(stats['times']),
                    'total_results': stats['total_results'],
                    'avg_results_per_query': stats['total_results'] / max(stats['success_count'], 1)
                }
            else:
                summary['method_stats'][method_name] = {
                    'success_rate': 0,
                    'avg_time': 0,
                    'error': 'No successful queries'
                }
        
        return summary
    
    def print_summary_report(self, summary: Dict[str, Any]):
        """In b√°o c√°o t√≥m t·∫Øt"""
        print("\n" + "="*80)
        print("üìä SEARCH METHODS COMPARISON REPORT")
        print("="*80)
        
        print(f"\nüìã Test Info:")
        print(f"  ‚Ä¢ Total Queries: {summary['test_info']['total_queries']}")
        print(f"  ‚Ä¢ Results per Query: {summary['test_info']['top_k']}")
        print(f"  ‚Ä¢ Test Time: {summary['test_info']['timestamp']}")
        
        print(f"\nüèÜ Performance Ranking:")
        
        # Sort methods by average time
        sorted_methods = []
        for method_name, stats in summary['method_stats'].items():
            if 'avg_time' in stats and stats['success_rate'] > 0:
                sorted_methods.append((method_name, stats))
        
        sorted_methods.sort(key=lambda x: x[1]['avg_time'])
        
        for i, (method_name, stats) in enumerate(sorted_methods, 1):
            print(f"\n  {i}. {method_name.upper()}")
            print(f"     ‚ö° Avg Time: {stats['avg_time']:.3f}s")
            print(f"     ‚úÖ Success Rate: {stats['success_rate']*100:.1f}%")
            print(f"     üìä Avg Results: {stats['avg_results_per_query']:.1f}")
            print(f"     ‚è±Ô∏è  Range: {stats['min_time']:.3f}s - {stats['max_time']:.3f}s")
        
        # Failed methods
        failed_methods = [name for name, stats in summary['method_stats'].items() 
                         if stats['success_rate'] == 0]
        
        if failed_methods:
            print(f"\n‚ùå Failed Methods: {', '.join(failed_methods)}")
        
        print("\n" + "="*80)
    
    def save_results(self, summary: Dict[str, Any], filename: str = None):
        """L∆∞u k·∫øt qu·∫£ ra file JSON"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"search_comparison_{timestamp}.json"
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(summary, f, indent=2, ensure_ascii=False)
        
        print(f"üíæ Results saved to: {filename}")

def main():
    """Main function ƒë·ªÉ ch·∫°y test"""
    print("üî¨ Medical Search Methods Comparison Test")
    print("Testing: Semantic, Hybrid, Parallel, Fast Hybrid Search")
    
    # Initialize test
    comparison = SearchComparison()
    
    # Run quick test v·ªõi 1 query
    print("\nüß™ Quick Test with single query:")
    quick_result = comparison.run_single_query_test("ƒëau ƒë·∫ßu v√† ch√≥ng m·∫∑t", top_k=5)
    
    # Ask user for full test
    print("\n" + "-"*50)
    user_input = input("ü§î Run full comparison test with all queries? (y/n): ").lower().strip()
    
    if user_input in ['y', 'yes', '1', 'ok']:
        # Run full test
        summary = comparison.run_full_comparison(top_k=5)
        
        # Print report
        comparison.print_summary_report(summary)
        
        # Save results
        save_input = input("\nüíæ Save detailed results to JSON file? (y/n): ").lower().strip()
        if save_input in ['y', 'yes', '1', 'ok']:
            comparison.save_results(summary)
    
    print("\n‚úÖ Test completed!")

if __name__ == "__main__":
    main()
